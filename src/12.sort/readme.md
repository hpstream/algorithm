## 排序
### 特点
1. 稳定性
2. 原地算法
 - 不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入
- 
###1. 冒泡排序
- 最好时间复杂度：O(n)
- 最坏时间复杂度：O(n^2)
- 平均时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定排序
  
### 2. 选择排序
> 从序列中找到最发的元素，然后与末尾的元素交换位置。
> 选择排序的交换次数远远少于冒泡排序，平均性能优于冒泡排序
- 最好时间复杂度：O(n^2)
- 最坏时间复杂度：O(n^2)
- 平均时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定排序

### 3. 堆排序（Heap）
> 堆排序可以认为是对选择排序的一种优化

- 最好时间复杂度：O(nlogn)
- 最坏时间复杂度：O(nlogn)
- 平均时间复杂度：O(nlogn)
- 空间复杂度：O(1)
- 稳定排序
	
### 4. 插入排序（Insertion Sort）
> 插入排序非常类似于扑克牌的排序
**执行流程**
1. 头部已经排好序，尾部待排序
2. 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

**什么是逆序对？**
数组[2,3,8,6,1]的逆序对为：[2,1],[3,1],[8,1],[8,6],[6,1] 共5个逆序对

> 插入排序的时间复杂度与逆序对的数量成正比，逆序对的数量越多，插入排序时间复杂度就越高。

- 最好时间复杂度：O(n)
- 最坏时间复杂度：O(n^2)
- 平均时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定排序

>当逆序对的数量极少时，插入排序的效率特别高，甚至速度比O(nlogn)级别的快速排序还要快；

### 二分查找
> 如果数组是无序的，平均时间复杂度：O(n);
> 如果数组是有序的，平均时间复杂度：O(logn)

思路：
```
[begin,end) mid = Math.floor((begin+end)/2)

if(mid>0)  [begin,mid)
if(mid<0)  [mid+1,end)

```