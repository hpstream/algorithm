## 排序
### 特点
1. 稳定性
2. 原地算法
 - 不依赖额外的资源或者依赖少数的额外资源，仅依靠输出来覆盖输入
- 
###1. 冒泡排序
- 最好时间复杂度：O(n)
- 最坏时间复杂度：O(n^2)
- 平均时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定排序
  
### 2. 选择排序
> 从序列中找到最发的元素，然后与末尾的元素交换位置。
> 选择排序的交换次数远远少于冒泡排序，平均性能优于冒泡排序
- 最好时间复杂度：O(n^2)
- 最坏时间复杂度：O(n^2)
- 平均时间复杂度：O(n^2)
- 空间复杂度：O(1)
- (不)稳定排序

### 3. 堆排序（Heap）
> 堆排序可以认为是对选择排序的一种优化

- 最好时间复杂度：O(nlogn)
- 最坏时间复杂度：O(nlogn)
- 平均时间复杂度：O(nlogn)
- 空间复杂度：O(1)
- 不稳定排序
	
### 4. 插入排序（Insertion Sort）
> 插入排序非常类似于扑克牌的排序
**执行流程**
1. 头部已经排好序，尾部待排序
2. 每当扫描到一个元素，就将它插入到头部合适的位置，使得头部数据依然保持有序

**什么是逆序对？**
数组[2,3,8,6,1]的逆序对为：[2,1],[3,1],[8,1],[8,6],[6,1] 共5个逆序对

> 插入排序的时间复杂度与逆序对的数量成正比，逆序对的数量越多，插入排序时间复杂度就越高。

- 最好时间复杂度：O(n)
- 最坏时间复杂度：O(n^2)
- 平均时间复杂度：O(n^2)
- 空间复杂度：O(1)
- 稳定排序

>当逆序对的数量极少时，插入排序的效率特别高，甚至速度比O(nlogn)级别的快速排序还要快；

### 二分查找
> 如果数组是无序的，平均时间复杂度：O(n);
> 如果数组是有序的，平均时间复杂度：O(logn)

思路：
```
[begin,end) mid = Math.floor((begin+end)/2)

if(mid>0)  [begin,mid)
if(mid<0)  [mid+1,end)

```

### 5. 归并排序(Merge Sort)

**执行流程**
1. 不断地将当前序列平均分割成2个子序列，直到不能分割(序列中只剩下1个元素)，直到不能再分割（序列中只剩下一个元素）
2. 不断的将2个子序列合并成一个有序序列
 

- 最好时间复杂度：O(nlogin)
- 最坏时间复杂度：O(nlogin)
- 平均时间复杂度：O(nlogin)
- 空间复杂度：O(n/2 + logn) = O(1)
- 稳定排序

### 快速排序（Quick Sort）

**执行流程**
1. 从序列中选择一个轴点元素，（假设每次选择0位置的元素为轴点元素）
2. 利用轴点元素（pivot）将序列分割成为2个子系列，将小于pivot的元素放到pivot前面，将大于pivot的元素放到pivot后面，等于放在那边都可以。
3. 对子序列进行，1，2操作，直到不能再分割（子序列中只剩下1个元素）

**快速排序的本质**
逐渐将每个元素转化成轴点元素

- 最好时间复杂度：O(nlogin)
- 最坏时间复杂度：O(n^2)
- 平均时间复杂度：O(nlogin)
- 空间复杂度：O(logn)
- 不稳定排序

### 希尔排序(Shell Sort)
> 希尔排序是把序列看作一个矩阵，分为m列，逐渐进行排序，因此希尔排序也被称之为，递减增量排序

- 最好时间复杂度：O(n)
- 最坏时间复杂度：O(n^4/3)~ O(n^2)
- 平均时间复杂度：取决于步长序列
- 空间复杂度：O(1)
- 不稳定排序

### 计数排序（Count Sort）
冒泡，选择，插入，归并，快速，希尔，堆排序，都是属于比较的排序，最低时间复杂度为O(nlogn)

计数排序，桶排序，基数排序，都不属于比较排序
> 是典型的空间换时间，在某个时候，平均复杂度可以比O(nlogn)更低

- 最好时间复杂度：O(n+k)
- 最坏时间复杂度：O(n+k)
- 平均时间复杂度：O(n+k)
- 空间复杂度：O(n+k)
- 不稳定排序

### 基数排序（Radix Sort）
> 基数排序非常适合用于整数排序（尤其是非负整数）

**执行流程**
依次对个位数，十位数，百位数，千位数，万位数，进行排序，从低位到高位

d表示最大值的位数，k表示进制
- 最好时间复杂度：O(d*(n+k)) O(kn+k)
- 最坏时间复杂度：O(d*(n+k)) O(kn+k)
- 平均时间复杂度：O(d*(n+k)) O(kn+k)
- 空间复杂度：O(n+k) O(dn)
- 稳定排序

### 桶排序（Bucket Sort）

**执行流程**
1. 创建一定数量的桶（比如用数组，链表作为桶）
2. 按照一定的规则（不同类型的数据，规则不同），将序列中的元素均匀的分配到对应的桶
3. 分别对每个桶进行单独排序
4. 将所有非空桶的元素合并成有序序列

m是桶的数量
- 最好时间复杂度：O(n+n*logn-n*logm) => O(n+k)
- 最坏时间复杂度：O(n+n*logn-n*logm) => O(n+k)
- 平均时间复杂度：O(n+n*logn-n*logm) => O(n+k)
- 空间复杂度：O(n+m)
- 稳定排序
