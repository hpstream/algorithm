## 什么是递归
函数(方法)直接或者间接调用自身。是一种常用的编程技巧

**注意：**
使用递归不是为了求得最优解，是为了简化解决问题的思路，代码更加简洁

### 递归的基本思想

1. 拆解问题
- 把规模大的问题变成规模较小的同类型问题
- 规模较小的问题不断变成规模更小的问题
- 规模小到一定程度可以直接得出它的解

2. 求解
- 由最小规模问题的解得出较大规模问题的解
- 由较大规模问题的解不断得出更大规模问题的解

### 递归的套路
1. 明确函数的功能
   1. 先不要去思考里面代码怎么写，首先搞清楚这个函数的干嘛用的，能完成什么功能？
2. 明确原问题与子问题的关系
   1. 寻找f(n)与f(n-1)的关系
3. 明确递归基(边界情况)
   1. 递归的过程中，子问题的规模在不断减少，当小到一定程度时，可以直接得出它的解
   2. 寻找递归基，相当于是思考：问题规模小到什么程度可以直接得出解

T(n) = T(n-1) + T(n-2) + O(1);

T(n) = 2T(n-2)+ T(n-3) + O(1) +  O(1)

T(n) = 3T(n-3)+ 2T(n-4) + O(1) + O(1) + 2*O(1)

T(n) = 5(T(n-4))+ 3T(n-5) +  O(1) + O(1) + 2O(1) + 3O(1)

T(n) = 8T(n-5) + 5T(n-6)  +  O(1) + O(1) + 2O(1) + 3O(1) + 5O(1)

T(n) = 13(T(n-6)) + 8(T(n-6)) +  O(1) + O(1) + 2O(1) + 3O(1) + 5O(1)+8O(1)

T(n) = 5T(n-4)+3T(n-5)+ 7*O(1)

### 递归转非递归
递归调用的过程中，会将每个调用的参数，局部变量保存在了对应的栈帧中。

若递归调用深度较大，会占用比较多的栈空间，甚至导致栈溢出。
在有些时候，递归存在大量的重复计算，性能非常差
这个时候考虑将递归转成非递归（低递归100%可以转成非递归）

方式一：
1. 自己维护一个栈，模拟栈帧的调用
2. 用统一的变量，保存栈帧中的参数

### 尾调用（Tail Call）

1. 尾调用：一个函数的最后一个动作是调用函数
   1. 如果最后一个动作是调用自身，称为尾递归，是尾调用的特殊情况
2. 一些编译器能对尾调用进行优化，以达到节省栈空间的目的

## 回溯（Bakc Tracking）

1. 回溯可以理解为：通过选择不同的岔路口来通往目的地
   1. 每一步都选择出一条路处罚，能进则进，不能进则退一步(回缩)，换一条路再试
2. 树，图的深度优先搜索（DFS）就是典型的回溯应用

### 八皇后问题

1. 思路一：暴露出奇迹
   1. 从64个格子中选出任意8个鸽子摆放皇后，检查每一种摆放的可能性
   2. 一共C64,8(排列组合中的组合)中摆法(大概是4.4*10^9)中
2. 思路二：根据题意减少暴力程度
   1. 很显然，每一行只能放一个皇后，所以共有8^8中摆法，检查没一种的可能性
3. 思路三：回溯法


